# 框架篇面试题 - 参考回答

## 目录
- [Spring 框架中的单例 Bean 是线程安全的吗？](#spring-框架中的单例-bean-是线程安全的吗)
- [什么是 AOP](#什么是-aop)
- [Spring 中的事务实现原理](#spring-中的事务实现原理)
- [Spring 中事务失效的常见场景](#spring-中事务失效的常见场景)
- [Spring Bean 的生命周期](#spring-bean-的生命周期)
- [Spring 中的循环依赖](#spring-中的循环依赖)
- [构造方法循环依赖的解决办法](#构造方法循环依赖的解决办法)
- [SpringMVC 执行流程](#springmvc-执行流程)
- [Spring Boot 自动配置原理](#spring-boot-自动配置原理)
- [Spring 常见注解](#spring-常见注解)
- [SpringMVC 常见注解](#springmvc-常见注解)
- [Spring Boot 常见注解](#spring-boot-常见注解)
- [MyBatis 执行流程](#mybatis-执行流程)
- [MyBatis 是否支持延迟加载](#mybatis-是否支持延迟加载)
- [MyBatis 一级、二级缓存](#mybatis-一级二级缓存)
- [MyBatis 二级缓存清理时机](#mybatis-二级缓存清理时机)

---

## Spring 框架中的单例 Bean 是线程安全的吗？

Spring 中的单例 Bean 并不是线程安全的。  

当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，多个线程会并发执行对应的业务逻辑。如果该逻辑中存在对单例对象的成员属性修改，就必须考虑线程同步问题。  

Spring 并没有对单例 Bean 提供额外的多线程封装，线程安全需要开发者自行保证。  

通常情况下，Spring 项目中的 Bean 多为无状态对象（例如 `Service` 和 `DAO` 类），因此在这种情况下是线程安全的。如果 Bean 有状态（如 `View Model` 对象），则需要开发者保证线程安全。常见做法是将作用域从 **singleton** 改为 **prototype**。

---

## 什么是 AOP

AOP 即面向切面编程（Aspect Oriented Programming）。  

在 Spring 中，AOP 主要用于将与业务无关、但对多个对象有影响的公共逻辑抽取出来，降低耦合并提高复用率。例如日志记录、事务管理、权限控制等。  

常见应用场景：  
- 公共日志保存  
- 事务处理  
- 数据加密  

例如在某些系统中，可以通过 **切点表达式** 定位需要增强的方法，并使用 **环绕通知** 来拦截请求参数、类信息、方法信息等，再做统一处理。

---

## Spring 中的事务实现原理

Spring 的事务本质上是通过 AOP 实现的。  

在方法执行前开启事务，执行完成后根据执行情况决定提交或回滚事务。Spring 通过动态代理（JDK 或 CGLIB）对方法进行拦截，从而实现声明式事务。

---

## Spring 中事务失效的常见场景

1. **异常被捕获后未抛出**  
   方法中异常被 `try-catch` 捕获并吞掉，事务不会回滚。应在处理后重新抛出。

2. **抛出的是检查异常**  
   Spring 默认只对运行时异常（`RuntimeException`）回滚。若需对所有异常回滚，应在 `@Transactional` 中配置：  
   ```java
   @Transactional(rollbackFor = Exception.class)
   ```

3. **方法不是 public 修饰**  
   Spring AOP 基于代理机制，非 `public` 方法不会被事务代理，事务不生效。

---

## Spring Bean 的生命周期

1. **读取 BeanDefinition**  
   获取 Bean 定义信息，包括类路径、作用域、是否懒加载等。  

2. **实例化 Bean**  
   调用构造方法创建实例。  

3. **依赖注入**  
   执行依赖注入（如 `@Autowired`）。  

4. **Aware 接口回调**  
   如果实现了 `Aware` 接口，执行相关方法。  

5. **BeanPostProcessor 前置处理**  

6. **初始化方法**  
   - 实现 `InitializingBean` 接口  
   - 使用 `init-method` 或 `@PostConstruct`  

7. **BeanPostProcessor 后置处理**  
   可能生成代理对象。  

8. **销毁阶段**  
   执行 `DisposableBean` 接口或 `destroy-method`。

---

## Spring 中的循环依赖

循环依赖指两个或多个 Bean 互相依赖，形成闭环，例如 A 依赖 B，B 依赖 A。  

Spring 使用 **三级缓存** 解决大部分循环依赖问题：  
- **一级缓存**：`singletonObjects`，存放完全初始化的单例对象。  
- **二级缓存**：`earlySingletonObjects`，存放早期暴露的单例对象。  
- **三级缓存**：`singletonFactories`，存放对象工厂 `ObjectFactory`。  

**解决流程简述：**  
1. 实例化 A，放入三级缓存。  
2. A 依赖 B，开始创建 B。  
3. 实例化 B，放入三级缓存。  
4. B 依赖 A，通过三级缓存获取 A 的工厂创建早期 A 对象（可能是代理对象），放入二级缓存。  
5. B 注入 A 后完成初始化，进入一级缓存。  
6. 回到 A，注入已完成的 B，完成初始化，进入一级缓存。  
7. 清理二级缓存中临时对象。

---

## 构造方法循环依赖的解决办法

Spring 无法解决构造方法中的循环依赖，因为构造方法在最开始就执行。  

常见解决方式：  
- 使用 `@Lazy` 延迟加载  
- 引入接口分离或重构依赖关系  

---

## SpringMVC 执行流程

1. 用户发送请求至 `DispatcherServlet`。  
2. `DispatcherServlet` 调用 `HandlerMapping` 查找处理器。  
3. `HandlerMapping` 返回 `Handler` 与拦截器。  
4. `DispatcherServlet` 调用 `HandlerAdapter`。  
5. `HandlerAdapter` 执行具体 `Handler`（Controller）。  
6. `Controller` 执行完成，返回 `ModelAndView`。  
7. `HandlerAdapter` 将结果交给 `DispatcherServlet`。  
8. `DispatcherServlet` 调用 `ViewResolver` 解析视图。  
9. `DispatcherServlet` 渲染视图并返回响应。  

在前后端分离项目中，通常使用 `@ResponseBody` 直接返回 JSON，而不涉及视图解析。

---

## Spring Boot 自动配置原理

Spring Boot 的入口类一般使用 `@SpringBootApplication` 注解，它包含：  
- `@SpringBootConfiguration`  
- `@EnableAutoConfiguration`  
- `@ComponentScan`  

其中 `@EnableAutoConfiguration` 是核心。  

Spring Boot 会通过 `@Import` 导入配置选择器，读取 `META-INF/spring.factories` 中的配置类。配置类会根据条件注解（如 `@ConditionalOnClass`）判断是否加载 Bean，实现自动配置。

---

## Spring 常见注解

- **声明 Bean**：`@Component`、`@Service`、`@Repository`、`@Controller`  
- **依赖注入**：`@Autowired`、`@Qualifier`、`@Resource`  
- **作用域**：`@Scope`  
- **配置相关**：`@Configuration`、`@ComponentScan`、`@Bean`  
- **AOP 相关**：`@Aspect`、`@Before`、`@After`、`@Around`、`@Pointcut`

---

## SpringMVC 常见注解

- `@RequestMapping`：映射请求路径  
- `@RequestBody`：接收请求 JSON 并转换为对象  
- `@RequestParam`：绑定请求参数  
- `@PathVariable`：获取路径参数  
- `@ResponseBody`：返回对象序列化为 JSON  
- `@RequestHeader`：获取请求头  
- `@PostMapping`、`@GetMapping`：快捷方式请求映射  

---

## Spring Boot 常见注解

- `@SpringBootApplication`：核心注解，组合了配置、自动配置、组件扫描  
- `@SpringBootConfiguration`：等同于 `@Configuration`  
- `@EnableAutoConfiguration`：启用自动配置  
- `@ComponentScan`：开启包扫描  

---

## MyBatis 执行流程

1. 读取配置文件 `mybatis-config.xml`。  
2. 构建 `SqlSessionFactory`（单例，交给 Spring 管理）。  
3. 通过工厂创建 `SqlSession`。  
4. `SqlSession` 通过 `Executor` 执行 SQL。  
5. `Executor` 调用 `MappedStatement`，封装 SQL 信息。  
6. 输入参数映射。  
7. 执行 SQL，结果进行输出映射。

---

## MyBatis 是否支持延迟加载

MyBatis 支持延迟加载（Lazy Loading）。  

延迟加载指在需要数据时才执行 SQL 查询，不需要时不加载。可用于一对一或一对多关联对象。  

配置方式：  
```xml
<settings>
    <setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

**底层原理：**  
- 使用 CGLIB 代理创建对象。  
- 调用方法时，若属性未加载则触发 SQL 查询。  
- 查询结果填充后再次访问则直接返回。

---

## MyBatis 一级、二级缓存

- **一级缓存**：默认开启，基于 `SqlSession` 的缓存，作用域为当前会话，关闭或刷新后清空。  
- **二级缓存**：默认关闭，基于 `namespace`，跨 `SqlSession` 共享。需在全局和映射文件中手动开启。  

---

## MyBatis 二级缓存清理时机

当某个作用域（`SqlSession` 或 `namespace`）发生 `INSERT`、`UPDATE`、`DELETE` 操作后，默认会清空该作用域下所有 `SELECT` 的缓存。  
